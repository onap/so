/*-
 * ============LICENSE_START=======================================================
 * ONAP - SO
 * ================================================================================
 * Copyright (C) 2017 AT&T Intellectual Property. All rights reserved.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END=========================================================
 */

package org.openecomp.mso.logger;


import java.util.List;

import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;

import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.Appender;

import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;

@Path("/logging")
@Api(value="/logging",description="logging")
public class MsoLoggingServlet {

    private static final String DEBUGLOG = "asyncEELFDebug";
    private MsoLogger logger = MsoLogger.getMsoLogger (MsoLogger.Catalog.GENERAL);
    private static final String GENERAL_LOGGER = "com.att.eelf.error";
    private static final String AUDIT_LOGGER = "com.att.eelf.audit";
    private static final String METRICS_LOGGER = "com.att.eelf.metrics";

    @GET
    @Path("/setLevel/{logContext}/{level}")
    @Produces("text/plain")
    @ApiOperation(value="message print",response=Response.class)
    public Response setLogLevel (@PathParam("logContext") String logContext, @PathParam("level") String level) {
        logger.info (MessageEnum.LOGGER_SETUP, "", "");
        
        LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); 
		JoranConfigurator jc = new JoranConfigurator(); 
		jc.setContext(context); 
		Logger updateLogger = context.getLogger (logContext);
        
        if (updateLogger == null) {
            logger.info (MessageEnum.LOGGER_NOT_FOUND, logContext, "", "");
            String response = "Unknown logger: " + logContext;
            return Response.status (200).entity (response).build ();
        }
        
        Level currentLevel = updateLogger.getLevel();
        if (!currentLevel.equals(Level.toLevel(level))) {
        	Level newLevel = Level.toLevel (level);
        	updateLogger.setLevel (newLevel);
            logger.info (MessageEnum.LOGGER_UPDATE_SUC, updateLogger.getName (), currentLevel.toString(), newLevel.toString());
        }

        String response = "Log level set to: " + level + " for " + updateLogger.getName ();
        return Response.status (200).entity (response).build ();

    }

    @GET
    @Path("/loggers")
    @Produces("text/plain")
    @SuppressWarnings("rawtypes")
    @ApiOperation(value="message print",response=Response.class)
    public Response getLoggers () {
        StringBuilder response = new StringBuilder ();
        LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); 
		JoranConfigurator jc = new JoranConfigurator(); 
		jc.setContext(context); 
		List <Logger> loggerList = context.getLoggerList();
        for (Logger logger:loggerList) {
        	//if (logger.getLevel() != null) {
        		response.append(logger.getName()).append(":").append(logger.getLevel()).append(" (")
                    .append(logger.getEffectiveLevel()).append(")\n");
        	//}
        }
        return Response.status (200).entity (response).build ();

    }

    @GET
    @Path("/debug")
    @Produces("text/plain")
    @ApiOperation(value="message print",response=Response.class)
    @SuppressWarnings("rawtypes")
    /*
     * Debug log is used as a general log to store all the logs events, including events generated by MSO code or by
     * components used by MSO.
     * This method will only enable/disable the function to store MSO generated events into debug log,
     * since those events will also be generated to error, audit, metrics log.
     * The events generated by other components will not be affected by this interface.
     */
    public Response updateDebugAppender (@DefaultValue("true") @QueryParam("enable") Boolean enable) {
        String response;
        
		LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); 
		JoranConfigurator jc = new JoranConfigurator(); 
		jc.setContext(context); 
		List <Logger> loggerList = context.getLoggerList();
		Logger rootLogger = context.getLogger("ROOT");
        Appender appender = rootLogger.getAppender(DEBUGLOG);

        if (null == appender) {
        	return Response.status (500).entity ("Not able to found Debug appender. Please verify to make sure the needed logback file is present in the config folder.").build ();
        }

        if (enable) {
            logger.info (MessageEnum.LOGGER_UPDATE_DEBUG, "", "");

            for (Logger logger: loggerList) {
                if (isMsoLogger (logger.getName ()) && logger.getAppender (DEBUGLOG) == null && logger.getLevel () != null) {
                	logger.addAppender (appender);
                	logger.setAdditive(false);
                }
            }
            logger.info (MessageEnum.LOGGER_UPDATE_DEBUG_SUC, "enabled", "", "");
            response = "Debuglog successfully enabled.";
        } else {
            logger.info (MessageEnum.LOGGER_UPDATE_DEBUG, "", "");
            for (Logger logger: loggerList) {
                if (isMsoLogger (logger.getName ())) {
                	logger.detachAppender (appender);
                }
            }
            logger.info (MessageEnum.LOGGER_UPDATE_DEBUG_SUC, "disabled", "", "");
            response = "Debuglog successfully disabled.";
        }
        return Response.status (200).entity (response).build ();
        
        
    }

    private boolean isMsoLogger (String loggerName) {
        return loggerName.contains (GENERAL_LOGGER) || loggerName.equals (AUDIT_LOGGER)
               || loggerName.equals (METRICS_LOGGER);
    }

}
